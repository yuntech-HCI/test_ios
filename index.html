<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Unity WebGL Player | My project (2)</title>
    <link rel="shortcut icon" href="TemplateData/favicon.ico">
    <link rel="stylesheet" href="TemplateData/style.css">
  </head>
  <body>
      <div id="unity-container" class="unity-desktop">
          <canvas id="unity-canvas" width=960 height=600 tabindex="-1"></canvas>
          <div id="unity-loading-bar">
              <div id="unity-logo"></div>
              <div id="unity-progress-bar-empty">
                  <div id="unity-progress-bar-full"></div>
              </div>
          </div>
          <div id="unity-warning"> </div>
          <div id="unity-footer">
              <div id="unity-webgl-logo"></div>
              <div id="unity-fullscreen-button"></div>
              <div id="unity-build-title">My project (2)</div>
          </div>
      </div>
      <script>

          var container = document.querySelector("#unity-container");
          var canvas = document.querySelector("#unity-canvas");
          var loadingBar = document.querySelector("#unity-loading-bar");
          var progressBarFull = document.querySelector("#unity-progress-bar-full");
          var fullscreenButton = document.querySelector("#unity-fullscreen-button");
          var warningBanner = document.querySelector("#unity-warning");

          // Shows a temporary message banner/ribbon for a few seconds, or
          // a permanent error message on top of the canvas if type=='error'.
          // If type=='warning', a yellow highlight color is used.
          // Modify or remove this function to customize the visually presented
          // way that non-critical warnings and error messages are presented to the
          // user.
          function unityShowBanner(msg, type) {
              function updateBannerVisibility() {
                  warningBanner.style.display = warningBanner.children.length ? 'block' : 'none';
              }
              var div = document.createElement('div');
              div.innerHTML = msg;
              warningBanner.appendChild(div);
              if (type == 'error') div.style = 'background: red; padding: 10px;';
              else {
                  if (type == 'warning') div.style = 'background: yellow; padding: 10px;';
                  setTimeout(function () {
                      warningBanner.removeChild(div);
                      updateBannerVisibility();
                  }, 5000);
              }
              updateBannerVisibility();
          }

          var buildUrl = "Build";
          var loaderUrl = buildUrl + "/web.loader.js";
          var config = {
              dataUrl: buildUrl + "/web.data",
              frameworkUrl: buildUrl + "/web.framework.js",
              codeUrl: buildUrl + "/web.wasm",
              streamingAssetsUrl: "StreamingAssets",
              companyName: "DefaultCompany",
              productName: "My project (2)",
              productVersion: "0.1",
              showBanner: unityShowBanner,
          };

          // By default, Unity keeps WebGL canvas render target size matched with
          // the DOM size of the canvas element (scaled by window.devicePixelRatio)
          // Set this to false if you want to decouple this synchronization from
          // happening inside the engine, and you would instead like to size up
          // the canvas DOM size and WebGL render target sizes yourself.
          // config.matchWebGLToCanvasSize = false;

          // If you would like all file writes inside Unity Application.persistentDataPath
          // directory to automatically persist so that the contents are remembered when
          // the user revisits the site the next time, uncomment the following line:
          // config.autoSyncPersistentDataPath = true;
          // This autosyncing is currently not the default behavior to avoid regressing
          // existing user projects that might rely on the earlier manual
          // JS_FileSystem_Sync() behavior, but in future Unity version, this will be
          // expected to change.

          if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
              // Mobile device style: fill the whole browser client area with the game canvas:

              var meta = document.createElement('meta');
              meta.name = 'viewport';
              meta.content = 'width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes';
              document.getElementsByTagName('head')[0].appendChild(meta);
              container.className = "unity-mobile";
              canvas.className = "unity-mobile";

              // To lower canvas resolution on mobile devices to gain some
              // performance, uncomment the following line:
              // config.devicePixelRatio = 1;


          } else {
              // Desktop style: Render the game canvas in a window that can be maximized to fullscreen:

              canvas.style.width = "960px";
              canvas.style.height = "600px";
          }

          loadingBar.style.display = "block";

          var script = document.createElement("script");
          script.src = loaderUrl;
          script.onload = () => {
              createUnityInstance(canvas, config, (progress) => {
                  progressBarFull.style.width = 100 * progress + "%";
              }).then((unityInstance) => {
                  loadingBar.style.display = "none";
                  fullscreenButton.onclick = () => {
                      unityInstance.SetFullscreen(1);
                  };
              }).catch((message) => {
                  alert(message);
              });
          };

          document.body.appendChild(script);

      </script>

      <!-- === üëá Âä†Âú®ÂéüÊú¨ Unity HTML ÊúÄÂæåÈù¢Âç≥ÂèØ üëá === -->
      <script>
          document.addEventListener("DOMContentLoaded", () => {
              console.log("üì± Á≠âÂæÖ Unity ËºâÂÖ•ÂÆåÊàê...");

              // Á≠â Unity Âª∫Á´ãÂÆåÁï¢ÂæåÔºàcreateUnityInstance Âü∑Ë°åÂÆåÊàêÊôÇÔºâ
              // Unity ÊúÉÂ∞áÁâ©‰ª∂Â≠òÂú®ÂÖ®ÂüüËÆäÊï∏ "unityInstance"
              // ÊâÄ‰ª•ÊàëÂÄëÁî®‰∏ÄÂÄãÊ™¢Êü•Âô®ÂéªÁ≠âÂæÖÂÆÉËºâÂÖ•ÂÆåÊàê
              const waitForUnity = setInterval(() => {
                  if (typeof unityInstance !== "undefined" && unityInstance != null) {
                      clearInterval(waitForUnity);
                      console.log("‚úÖ Unity Â∑≤ËºâÂÖ•ÔºåÂïüÁî®ÊÑüÊ∏¨Âô®ÊåâÈàïÂª∫Á´ã‰∏≠...");

                      // Âª∫Á´ãÊåâÈàï
                      const btn = document.createElement("button");
                      btn.textContent = "ÂïüÁî®ÈáçÂäõÊÑüÊ∏¨Âô®";
                      btn.style.position = "fixed";
                      btn.style.top = "16px";
                      btn.style.left = "16px";
                      btn.style.zIndex = "9999";
                      btn.style.padding = "10px 16px";
                      btn.style.fontSize = "16px";
                      btn.style.fontWeight = "600";
                      btn.style.background = "#2563eb";
                      btn.style.color = "#fff";
                      btn.style.border = "none";
                      btn.style.borderRadius = "8px";
                      btn.style.boxShadow = "0 4px 10px rgba(37,99,235,0.3)";
                      document.body.appendChild(btn);

                      let accel = { x: 0, y: 0, z: 0 };
                      const alpha = 0.15;
                      let sx = 0, sy = 0, sz = 0;
                      let sending = false;

                      function handleMotion(e) {
                          const g = e.accelerationIncludingGravity || {};
                          let x = g.x || 0, y = g.y || 0, z = g.z || 0;
                          sx = sx + alpha * (x - sx);
                          sy = sy + alpha * (y - sy);
                          sz = sz + alpha * (z - sz);
                          accel = { x: sx, y: sy, z: sz };
                      }

                      async function requestPermissionIfNeeded() {
                          if (typeof DeviceMotionEvent !== "undefined" &&
                              typeof DeviceMotionEvent.requestPermission === "function") {
                              const res = await DeviceMotionEvent.requestPermission();
                              if (res !== "granted") throw new Error("‰ΩøÁî®ËÄÖÊú™ÊéàÊ¨ä");
                          }
                      }

                      btn.addEventListener("click", async () => {
                          try {
                              await requestPermissionIfNeeded();
                              window.addEventListener("devicemotion", handleMotion, { passive: true });
                              btn.textContent = "‚úÖ ÊÑüÊ∏¨Âô®Â∑≤ÂïüÁî®";
                              btn.disabled = true;
                              sending = true;
                              console.log("üì° ÈñãÂßãÊØè 0.1 ÁßíÂÇ≥ÈÄÅË≥áÊñôÁµ¶ Unity");

                              setInterval(() => {
                                  if (sending && unityInstance) {
                                      unityInstance.SendMessage("Receiver", "OnWebMessage", JSON.stringify(accel));
                                  }
                              }, 100);
                          } catch (e) {
                              alert("‚ùå ÊÑüÊ∏¨Âô®ÊéàÊ¨äÂ§±ÊïóÔºö" + e.message);
                          }
                      });
                  }
              }, 500);
          });
      </script>
      <!-- === üëÜ Âä†Âà∞ÈÄôË£°ÁµêÊùüÂç≥ÂèØ === -->

  </body>
</html>
